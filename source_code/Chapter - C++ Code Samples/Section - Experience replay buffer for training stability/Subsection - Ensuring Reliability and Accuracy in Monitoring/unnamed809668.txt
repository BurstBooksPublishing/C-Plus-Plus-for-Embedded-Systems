#include 
#include 
#include 
#include 

class ExperienceReplayBuffer {
private:
    std::deque, int, float, std::vector, bool>> buffer;
    size_t capacity;
    std::mt19937 rng;

public:
    ExperienceReplayBuffer(size_t capacity) : capacity(capacity), rng(std::random_device{}()) {}

    void addExperience(const std::vector& state, int action, float reward, 
                       const std::vector& next_state, bool done) {
        if (buffer.size() >= capacity) {
            buffer.pop_front(); // Remove oldest experience if buffer is full
        }
        buffer.emplace_back(state, action, reward, next_state, done);
    }

    std::vector, int, float, std::vector, bool>> 
    sampleBatch(size_t batch_size) {
        std::vector indices(buffer.size());
        std::iota(indices.begin(), indices.end(), 0);
        std::shuffle(indices.begin(), indices.end(), rng); // Shuffle indices

        std::vector, int, float, std::vector, bool>> batch;
        for (size_t i = 0; i < std::min(batch_size, indices.size()); ++i) {
            batch.push_back(buffe[indices[i]]); // Add sampled experiences to batch
        }
        return batch;
    }

    size_t size() const {
        return buffer.size();
    }
};